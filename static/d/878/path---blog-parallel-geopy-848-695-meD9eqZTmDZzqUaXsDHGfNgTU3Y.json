{"data":{"site":{"siteMetadata":{"title":"Spatial Paralysis","author":"Richard Law"}},"markdownRemark":{"id":"7db66fe0-caa8-5dd8-82ce-6fcb580f25fb","excerpt":"Geocoding: the process of taking an address as a piece of semi-structured text, and returning a coordinate somewhere on the surface of the…","html":"<p>Geocoding: the process of taking an address as a piece of semi-structured text, and returning a coordinate somewhere on the surface of the Earth. It’s very unlikely that you’re not going to use an online service to do this. This means a few things. Firstly, that you have to decide on a geocoding provider. Secondly, you’re going to have to sit tight while the geocoding takes place. Python can address both of these issues for you.</p>\n<h2><a href=\"https://geopy.readthedocs.org/en/1.11.0/\">GeoPy</a></h2>\n<p>GeoPy is a Python 2/3 module for accessing a whole suite of geocoding web services. As of version 1.10.0, these include: ArcGIS; Baidu; Bing; DataBC; GeocodeFarm; GoecoderDotUS; GeoNames; Google; IGN France; LiveAddress; NaviData; Nominatim (OSM); OpenCage; OpenMapQuest; Yahoo! BOSS Place Finder; What3Words; and Yandex.</p>\n<p>Of these, I would recommend Google if you are OK with a reasonably low limit but high tolerance to poorly-formatted addresses, or otherwise Nominatim. Nominatim is free, requires no API token, and only uses OpenStreetMap data. However, OpenMapQuest is even better, as it is also based on OSM, but doesn’t restrict you to geocoding in multiple threads.</p>\n<h2>Basic usage</h2>\n<p>Using GeoPy is great, because it abstracts away all the details of which provider you’re connecting to. Although I’m yet to try it, it would be trivial to iterate over a set of providers and actually produce multiple geocoded locations per address, perhaps as part of a process to determine error, or to average the returned locations.</p>\n<p>Here’s a short sample demonstrating the simplicity of the module:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> geopy<span class=\"token punctuation\">.</span>geocoders <span class=\"token keyword\">import</span> Nominatim\ngeolocator <span class=\"token operator\">=</span> Nominatim<span class=\"token punctuation\">(</span>country_bias<span class=\"token operator\">=</span><span class=\"token string\">'New Zealand'</span><span class=\"token punctuation\">,</span> timeout<span class=\"token operator\">=</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\ngeocoded <span class=\"token operator\">=</span> geolocator<span class=\"token punctuation\">.</span>geocode<span class=\"token punctuation\">(</span><span class=\"token string\">'Raglan, Waikato'</span><span class=\"token punctuation\">,</span> exactly_one<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> geocoded <span class=\"token keyword\">is</span> <span class=\"token operator\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># success</span>\n    lat <span class=\"token operator\">=</span> geocoded<span class=\"token punctuation\">.</span>latitude\n    lon <span class=\"token operator\">=</span> geocoder<span class=\"token punctuation\">.</span>longitude\n<span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># Here, perhaps you can run the geocoding function again,</span>\n    <span class=\"token comment\"># after cleaning your input a little bit</span>\n    <span class=\"token comment\"># Then you have recursion until you get a result!</span>\n    <span class=\"token keyword\">pass</span></code></pre></div>\n<p>If you want to use OpenMapQuest (for example), you just need to swap it out for Nominatim, and also remove the country bias (which OpenMapQuest doesn’t support).</p>\n<h2>Multiprocessing</h2>\n<p>There’s still a problem, despite all this. Geocoding takes forever. All web services take some time, really. But geocoding is special, given what is actually going on behind the scenes. A list of roughly 500 addresses, most of which needed the recursion I alluded to above, took me about 15 minutes to resolve. Duane Wilkins <a href=\"https://www.linkedin.com/pulse/easy-address-geocoding-duane-wilkins\">posted on LinkedIn recently</a> that using the Google geocoding service via Google Sheets resulted in about 800 addresses done in about 5 minutes. I suspect that they were clean, but Google is damn fast at geocoding. You’d expect that relative speed difference though: Nominatim is sitting on donated hardware.</p>\n<p>However both of these are very slow, in my opinion. Agonisingly so.</p>\n<p>A good Python free lunch to speed this up is to launch mutliple geoprocessing calls asynchronously. In my case, I had a small number of very long and poorly-formatted adddresses that took forever to resolve because the geocoder had to be performed multiple times, most of which resulted in nothing as the string was progressively cleaned, or indeed stripped of information that the geocoder simply could not understand (“5 nm out to sea east of Tauranga” is the best example). What if I could get these slow processes running, and run others alongside, in parallel? This is totally possible! And because Python is batteries-included, it is very, very easy!</p>\n<p>In my case, I had a list of objects (<code class=\"language-text\">sightings</code>) which are members of a class that has a method called <code class=\"language-text\">geocode</code> that essentially launches the geocoding routine I showed you above. (In my case, the function doesn’t return anything, but has the side-effect of setting each Address object’s <code class=\"language-text\">latitude</code> and <code class=\"language-text\">longitude</code>.)</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> multiprocessing\n\naddresses <span class=\"token operator\">=</span> <span class=\"token comment\"># Gather a list of Address objects with a `geocode`</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">geocode_worker</span><span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    address<span class=\"token punctuation\">.</span>geocode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> address\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># Start as many worker processes as you have cores</span>\n    pool <span class=\"token operator\">=</span> multiprocessing<span class=\"token punctuation\">.</span>Pool<span class=\"token punctuation\">(</span>processes<span class=\"token operator\">=</span>multiprocessing<span class=\"token punctuation\">.</span>cpu_count<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># Apply geocode worker to each address, asynchronously</span>\n    addresses <span class=\"token operator\">=</span> pool<span class=\"token punctuation\">.</span><span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span>geocode_worker<span class=\"token punctuation\">,</span> addresses<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">if</span> __name__ <span class=\"token operator\">==</span> <span class=\"token string\">'__main__'</span><span class=\"token punctuation\">:</span>\n    main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"custom-block newthought\"><div class=\"custom-block-heading\">A quick gotcha!</div><div class=\"custom-block-body\"><p>The worker function has to be <a href=\"http://docs.python.org/library/pickle.html#what-can-be-pickled-and-unpickled\">able to be pickled</a>. In simple terms, you have to have the worker function at the top level. The above snippet would not work if <code class=\"language-text\">geocode_worker</code> were defined within <code class=\"language-text\">main</code>. In that case, you’d see this error:</p><div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">cPickle.PicklingError: Can\\<span class=\"token string\">'t pickle &lt;type '</span>function'<span class=\"token operator\">></span>: attribute lookup __builtin__.function failed</code></pre></div></div></div>\n<div class=\"custom-block newthought\"><div class=\"custom-block-heading\">Don’t use Nominatim for this!</div><div class=\"custom-block-body\"><p>I made the mistake of <em>not</em> reading <a href=\"https://nominatim.openstreetmap.org/\">the usage restrictions</a> of the Nominatim geocoding service, and forgetting a debug switch, and then launched tens of requests at the same time, repeatedly, hundreds of times, and then had my IP address rate limited. Currently I can’t even <em>visit</em> nominatim.openstreetmap.org, let alone use the geocoder.</p></div></div>\n<p>The restriction is that you must use a single thread. That is, you must not do what I just showed you using Nominatim as your geocoding service, or you will end-up thrashing their limited resources. You also should really cache the results as they come in.</p>\n<p>However, OpenMapQuest uses Nominatim but does not have usage restrictions. You can launch some nice parallel processes with this geocoder… just be respectful.</p>\n<h2>Results</h2>\n<p>I achieved a speed-up of around 20x over the full set. The small number of dirty addresses that earlier caused the geocoder to hang still did so, but real work was going on around them; they were no longer blocking.</p>\n<p>Looking at the logs, here’s what the difference in processing looks like for a sample of my addresses. When you see <code class=\"language-text\">fail</code>, that is when my recursion kicks in that applies an algorithm to clean the address string before trying to geocode again.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token string\">'Gluepot Road, Oropi, Tauranga, North Island'</span> ← geocoder starting up\n<span class=\"token string\">'Gluepot Road, Oropi, Tauranga, New Zealand'</span> ← fail\n<span class=\"token string\">'Gluepot Road, Tauranga, New Zealand'</span> -37.8475939 176.1500778 ← success\n<span class=\"token string\">'Maungaraki, Lower Hutt, North Island'</span> ← geocoder starting up\n<span class=\"token string\">'Maungaraki, Lower Hutt, New Zealand'</span> -41.2058337 174.8800422 ← success\n<span class=\"token string\">'Rimutaka Ranges, Wairarapa, North Island'</span> ← geocoder starting up\n<span class=\"token string\">'Rimutaka Ranges, Wairarapa, New Zealand'</span> ← fail\n<span class=\"token string\">'Rimutaka, Wairarapa, New Zealand'</span> -41.3573081 175.0005109 ← success\n<span class=\"token string\">'Mourea, Rotorua, North Island'</span> ← geocoder starting up\n<span class=\"token string\">'Mourea, Rotorua, New Zealand'</span> -38.0442035 176.3261444 ← success\n<span class=\"token string\">'Tauranga, North Island'</span> ← geocoder starting up\n<span class=\"token string\">'Tauranga, New Zealand'</span> -37.6867319 176.1673614 ← success\n<span class=\"token string\">'Waihopai Valley, Marlborough, South Island'</span> ← geocoder starting up\n<span class=\"token string\">'Waihopai Valley, Marlborough, New Zealand'</span> -41.5149705 173.7897351 ← success\n<span class=\"token string\">'At sea off the coast of the Bay of Plenty, North Island'</span> ← geocoder starting up\n<span class=\"token string\">'At sea off the coast of the Bay of Plenty, New Zealand'</span> ← fail\n<span class=\"token string\">'At Bay Plenty, New Zealand'</span> ← fail\n<span class=\"token string\">'sea off the coast of the Bay of Plenty, New Zealand'</span> ← fail\n<span class=\"token string\">'Bay of Plenty, New Zealand'</span> -37.9503755 176.938287362 ← success\n<span class=\"token string\">'Taupo, North Island'</span> ← geocoder starting up\n<span class=\"token string\">'Taupo, New Zealand'</span> -38.6883048 176.0755486 ← success\nDone <span class=\"token keyword\">in</span> 16s</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token string\">'Gluepot Road, Oropi, Tauranga, North Island'</span> ← geocoder starting up\n<span class=\"token string\">'Maungaraki, Lower Hutt, North Island'</span> ← geocoder starting up\n<span class=\"token string\">'Rimutaka Ranges, Wairarapa, North Island'</span> ← geocoder starting up\n<span class=\"token string\">'Mourea, Rotorua, North Island'</span> ← geocoder starting up\n<span class=\"token string\">'Waihopai Valley, Marlborough, South Island'</span> ← geocoder starting up\n<span class=\"token string\">'Tauranga, North Island'</span> ← geocoder starting up\n<span class=\"token string\">'At sea off the coast of the Bay of Plenty, North Island'</span> ← geocoder starting up\n<span class=\"token string\">'Taupo, North Island'</span> ← geocoder starting up\n<span class=\"token string\">'Tauranga, New Zealand'</span> -37.6867319 176.1673614 ← success\n<span class=\"token string\">'Mourea, Rotorua, New Zealand'</span> -38.0442035 176.3261444 ← success\n<span class=\"token string\">'Waihopai Valley, Marlborough, New Zealand'</span> -41.5149705 173.7897351 ← success\n<span class=\"token string\">'Taupo, New Zealand'</span> -38.6883048 176.0755486 ← success\n<span class=\"token string\">'Gluepot Road, Oropi, Tauranga, New Zealand'</span> ← fail\n<span class=\"token string\">'Rimutaka Ranges, Wairarapa, New Zealand'</span> ← fail\n<span class=\"token string\">'Maungaraki, Lower Hutt, New Zealand'</span> -41.2058337 174.8800422 ← success\n<span class=\"token string\">'At sea off the coast of the Bay of Plenty, New Zealand'</span> ← fail\n<span class=\"token string\">'Gluepot Road, Tauranga, New Zealand'</span> -37.8475939 176.1500778 ← success\n<span class=\"token string\">'Rimutaka, Wairarapa, New Zealand'</span> -41.3573081 175.0005109 ← success\n<span class=\"token string\">'At Bay Plenty, New Zealand'</span> ← fail\n<span class=\"token string\">'sea off the coast of the Bay of Plenty, New Zealand'</span> ← fail\n<span class=\"token string\">'Bay of Plenty, New Zealand'</span> -37.9503755 176.938287362 ← success\nDone <span class=\"token keyword\">in</span> 4s</code></pre></div>\n<p>Notice the difference? In the latter case, there are multiple processes: 8 addresses get geocoded at once. They don’t return in order because they’re all happening at the same time and take different lengths of time to complete depending on their complexity. Failing addresses don’t prevent others from getting underway, and the whole process is so much smoother.</p>\n<p>The blocking geocoder ran in 16 seconds, while the second took only 4 seconds. Extrapolate that over hundreds of addresses, and before you declare that that is still not worth the effort, look how little code I had to write. It pays off even for very small, one-off jobs.</p>\n<p>There is much more that can be done with Python’s built-in multiprocessing, particularly using queues. There are a bunch of third-party modules that also implement the idea. I encourage you to explore, perhaps by looking at tutorials for how to write a daemon, and then make something that polls multiple related APIs at the same time, populating a common database in near real time.</p>","frontmatter":{"title":"Parallel geocoding in Python with geopy","date":"10:24 AM, Thursday September 10, 2015","updated":null,"path":null},"fields":{"slug":"/blog/parallel-geopy/"}}},"pageContext":{"slug":"/blog/parallel-geopy/","previous":{"fields":{"slug":"/blog/mediawatch/"},"frontmatter":{"title":"Mediawatch on the role of data journalism","updated":null,"date":"2015-07-04T01:00:00.000Z","path":null,"tags":["data journalism"]}},"next":{"fields":{"slug":"/blog/spatial-is-not-that-special/"},"frontmatter":{"title":"Spatial isn't that special","updated":null,"date":"2015-11-01T17:00:00.000Z","path":"/blog/spatial-not-special","tags":["GIS","opinion"]}}}}