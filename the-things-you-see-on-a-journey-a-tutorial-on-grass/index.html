<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>The things you see on a journey<br><small>A tutorial on GRASS, bash and Leaflet</small></title>
  <meta name="description" content="What you'll be making: identifying the land that you can feasibly see from the train in the central plateau of New Zealand">


  <link rel="stylesheet" href="/css/tufte.css">
  <link rel="shortcut icon" type="image/png" href="/favicon.png" >

  <!-- Google Fonts loaded here depending on setting in _data/options.yml true loads font, blank does not-->
  
    <link href='//fonts.googleapis.com/css?family=Lato:400,400italic' rel='stylesheet' type='text/css'>
  
  <!-- Load up MathJax script if needed ... specify in /_data/options.yml file-->
  
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

  <link rel="canonical" href="http://www.nearimprov.com/the-things-you-see-on-a-journey-a-tutorial-on-grass/">
  <link rel="alternate" type="application/rss+xml" title="nearimprov" href="http://www.nearimprov.com/feed.xml" />
</head>

  <body>
    <!--- Header and nav template site-wide -->
<header>
    <nav class="group">
	<a href="/"><img class="badge" src="/assets/img/new_badge.png" alt="CH"></a>
	
		
		    
		      <a href="/feed.xml"></a>
		    
	    
  	
		
		    
		      <a href="/">blog</a>
		    
	    
  	
		
		    
		      <a href="/about/">About</a>
		    
	    
  	
		
		    
		      <a href="/projects/">Projects</a>
		    
	    
  	
		
  	
	</nav>
</header>

    <article class="group">
      <h1>The things you see on a journey<br><small>A tutorial on GRASS, bash and Leaflet</small></h1>
<p class="subtitle">June 1, 2015</p>


<p><br /></p>
<figure class="fullwidth"><img src="/./assets/example.png" /><figcaption>What you'll be making: identifying the land that you can feasibly see from the train in the central plateau of New Zealand</figcaption></figure>

<p>Some moons ago, I met Pierre Roudier, who works at <a href="http://www.landcareresearch.co.nz/home">Landcare Research New Zealand</a>, at a workshop on PostGIS being held at the National Institute for Water and Atmospheric Research (<a href="https://www.niwa.co.nz/">NIWA</a>). I was just getting started on PostGIS at the time, having identified that I was probably going to need it for my masters thesis. The two-day session, led by Digital Mapping Solutions New Zealand (<a href="http://www.mapsolutions.co.nz/">DMS</a>), was brilliant. It gave me just enough of an introduction to PostGIS to realise its capability, and a leg-up to explore the rest on my own. I ended up relying entirely on PostGIS for my masters thesis, and now I swear by PostGIS and PL/pgsql as the solution to most issues calling for a spatial database.</p>

<p>What has this got to do with anything? A few things:</p>

<ol>
  <li>
    <p>For the love of all things holy, attend events like these if you can. You meet interesting people, get pizza (I ate kangaroo), and get a kick up the bum to learn new things that, honestly, you wouldn’t have bothered learning on your own. (In my case, the only reason I was able to attend was that I’d won a small cash prize for talking about my thesis—so you if you’re studying, try jump on small opportunities like that, too.)</p>
  </li>
  <li>
    <p>Pierre ran a tutorial at the end of the first day on GRASS GIS. It really piqued my interest in GRASS. At the time, I was struggling with a batch viewshed calculation for work using ArcGIS. It was falling over due to the size of the computation. I described the problem to Pierre, and he said that it sounded like something GRASS could do no problem. Problem was, I’d never used GRASS. It looked hard and scary: it barely has a GUI. Pierre gave me a headstart on the computation, and I adapted his example to my need. It wasn’t actually that bad, once I’d seen a complete, straightforward example.</p>
  </li>
  <li>
    <p>I realised the value of a gentle introduction to a new technique, that actually fulfills some goal you have in mind.</p>
  </li>
</ol>

<p>This last point is now really important to me. If I’m trying to learn something new, it has never truly helped me to open a book or the documentation and work through silly, disconnected examples one by one. I actually have to make something useful for myself. <strong>Solve your own, tangible problem.</strong></p>

<p>Doing this gives you enough motivation to finish, to finish well, and to know when you have finished. It also means you run into a wide variety of problems that your textbooks examples never mention; like, how do you write an iterator in bash?</p>

<h2 id="what-are-you-going-to-learn">What are you going to learn?</h2>

<p>This is a tutorial on using GRASS, Git, Leaflet, bash, Javascript, CSS, HTML, and hosting map tiles on Amazon AWS. Yes, all of those. No, not to exhaustion. Rather, I’ve written the tutorial that I would like to have found a few months ago. A tutorial that takes a tangible (albeit frivolous) problem to completion, and uses a realistic combination of tools to solve it. You’ll see how these separate tools come together, and how you could then take pieces here and there and work on something completely different. That’s an effective way to learn, if you invest into the idea of the project, and are willing to use this tutorial as a springboard for your own idea.</p>

<p>The end result is this <a href="http://www.nearimprov.com/train-landscapes">interactive map</a>.<label for="sn-id-note-on-tiles" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-id-note-on-tiles" class="margin-toggle" /><span class="sidenote">The map tiles are now broken, as AWS is not free, and I was not willing to pay to host them. </span></p>

<h2 id="what-i-cant-cover">What I can’t cover</h2>

<p>I will not cover <a href="http://readwrite.com/2013/09/30/understanding-github-a-journey-for-beginners-part-1">beginning with Git</a>, or fundamental Git concepts. But you’ll learn some commands and how to host an interactive map on the Internet for free with Github pages (<em>gh-pages</em>).</p>

<p>I will not cover getting started with GRASS. Although this won’t be a terrible introduction, I’m not detailing introductory concepts or using the GUI.<label for="sn-id-grass-tutorials" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-id-grass-tutorials" class="margin-toggle" /><span class="sidenote">Try [<a href="http://grass.osgeo.org/documentation/first-time-users/">1</a>], [<a href="http://grass.osgeo.org/grass70/manuals/helptext.html">2</a>] or [<a href="http://grasswiki.osgeo.org/wiki/Quick_wxGUI_tutorial">3</a>] instead, and then come back. </span> I had the benefit of a hands-on GRASS introduction at the DMS/NIWA workshop.</p>

<p>I won’t be discussion web hosting of maps in much depth. I’m not much of a web developer, and I’ve only tinkered with Amazon AWS to get this to work. I’m not an authority.</p>

<h2 id="what-do-you-need">What do you need?</h2>

<p>If you want to code along, you’ll need to install GRASS GIS (6.4 or 7.0). Git is optional; if you’re not familiar with it, I’d like to just show you how can use it in a little project like this.</p>

<p>I use Ubuntu for my desktop operating system. I don’t know how easy GRASS is to install on Windows or Mac, but I like to use the <a href="https://launchpad.net/~ubuntugis/+archive/ubuntu/ubuntugis-unstable">ubuntugis-unstable PPA</a>. This has GRASS 6.4 bundled up. GRASS 7.0 is faster due to the addition of new functions, so use that if you’re comfortable. If you’re not using a flavour of Linux, look into getting a virtual machine set up—it’s surprisingly easy and you’ll not regret it.</p>

<p>I’m also going to have to assume a modicum of familiarity with GIS, and some programming concepts (variables, iteration, functions, etc.). Yet you also need a willingness to learn! I’m still learning more about programming every day, even though I now get paid to do it, so if there’s anything that I seem to have brushed over, don’t feel too shy to ask me to explain it further.</p>

<h1 id="the-problem">The problem</h1>

<p>I talked to Pierre about a train trip across the North Island of New Zealand, known as the <em>Overlander</em>. He often takes the train to get to Wellington, and I’ve taken the Overlander several times to get between Auckland and Wellington. It is a lot slower than flying (by around 11+ hours), but personally I find it more enjoyable. In addition to your ability to get some solid solo productive time, it is very scenic. Being Spatial Scientists™, Pierre and I discussed how one could go about quantifying the <em>scenic-ness</em>… <em>scenicity</em>… the <em>je ne sais quoi</em> of the trip.</p>

<p>To solve this problem, you need to think abstractly about it, and then apply that back to the real problem, phrased in reduced, but practical terms:</p>

<p><strong>Given a line feature, how can you determine the places that are visible are from the line?</strong></p>

<p>Translated into the vernacular: if you’re sitting on the train, what can you see out of the window?</p>

<p>What could be taken into consideration in this case, from a spatial perspective? The most straightforward ideas include: what is the terrain like?<label for="sn-id-block1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-id-block1" class="margin-toggle" /><span class="sidenote">Hills block views of what is behind them. </span> How far can you see out the window?<label for="sn-id-block2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-id-block2" class="margin-toggle" /><span class="sidenote"><a href="http://en.wikipedia.org/wiki/Horizon#Distance_to_the_horizon">Distance to the horizon</a>, coupled with personal eyesight, and atmospheric refraction. </span></p>

<p>The not-so-straightforward, or even unresolvable issues include: are you on the left or right side of the train? Is the train going north or south? What speed is the train travelling at? Can you actually see out of the window? Is it dark? Are you asleep? Are there trees in the way? Are there tunnels?</p>

<p>Like all good spatial problems, the difficult issues outnumber the tractable ones. <strong>We’re just going to be thinking about visibility as determined by the bare terrain, using a constant distance to the horizon.</strong> This (arguably) gives us some measurement of the <em>maximum extent</em> of space that is visible, which could be refined further.</p>

<p>The two most influential decisions are the resolution of our terrain model, which determines blocking, and the distance to the horizon, which in an ideal world considers the curvature of the earth and an observer’s elevation.</p>

<h3 id="setting-up-with-git">Setting up with Git</h3>

<p>Launch your terminal, and navigate to somewhere where we can place a folder of interesting stuff (our project code and input data).</p>

<p><code class="highlighter-rouge">git clone</code> my GitHub repository with the following command:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">git clone https://github.com/alpha-beta-soup/train-landscapes</code></pre></figure>

<p>This creates a folder called <code class="highlighter-rouge">train-landscapes</code> in your current directory, within which the project is “cloned”: duplicated for your local consumption.</p>

<p>If you browse my Github repository in your web browser via the link in the <code class="highlighter-rouge">git clone</code> command, you’ll see that I originally “forked” this project from Pierre. That is, he started it, and I carried it on with my own changes. Pierre wrote the initial version of the GRASS procedure, targeting GRASS version 7. I adjusted this script, to make it work a bit faster with a larger input and higher resolution raster terrain model. I also made a second version that would work with GRASS 6.4, which is what I was using at the time. That’s what’s great about Github and open source code generally: being able to take someone else’s idea, and use it or run with it.</p>

<p>After cloning, you’ll see that there are a few files and folders, if you enter the <code class="highlighter-rouge">train-landscapes</code> directory. <code class="highlighter-rouge">.gitignore</code> is a text file with the following contents:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">data/</code></pre></figure>

<p>This tells Git to not track files (or changes to files) in the directory <code class="highlighter-rouge">data/</code> (which contains the source and output data, like the terrain DEM/hillshade model that I used as input).</p>

<p>The hillshade and digital elevation model (DEM) I used for this project are several gigabytes in size; I haven’t included them in the project to save you the bandwidth. Likewise, the tiles that actually constitute what you see on the map aren’t on Github either (they’re hosted by Amazon, more on that later). The <code class="highlighter-rouge">.gitignore</code> file is a handy way to manage issues like this one on excluding large datasets from source control when they don’t need it. For following along with this tutorial, you can download any DEM of New Zealand (projected to NZTM NZGD2000) that you have the rights to use. (You can of course pick a region anywhere else in the world.)</p>

<p>We also have <code class="highlighter-rouge">README.md</code>, which is the Markdown file that provides the documentation you can see on the front page of the GitHub repository for this project.</p>

<p><code class="highlighter-rouge">index.html</code> is where we have a simple webpage displaying a Leaflet map. We’ll get to this later.</p>

<p>The directory <code class="highlighter-rouge">data</code> contains the input vector features I used for this project: the train and road features that we determine visibility from. However, you can’t actually download this directory, as I’ve added it to the <code class="highlighter-rouge">.gitignore</code>.</p>

<p>The directory <code class="highlighter-rouge">source</code> contains the real work: our project code. We can list its contents from the terminal with the <code class="highlighter-rouge">ls</code> command:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">ls <span class="nb">source</span>/<span class="k">*</span>

  generate_los.sh
  generate_los_70.sh
  make_map.js
  obtain_corners.py
  style.css</code></pre></figure>

<p>The <code class="highlighter-rouge">generate_los</code> shell scripts (<code class="highlighter-rouge">.sh</code>) are files that contain a series of commands that will be understood by GRASS GIS, versions 6.4 and 7. Let’s consider them now.</p>

<h3 id="grass-and-shell-scripts">GRASS and shell scripts</h3>

<p>If you have installed GRASS, you can start it up at the command line by running the appropriate command for your version of GRASS:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">grass64</code></pre></figure>

<p>or</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">grass70</code></pre></figure>

<p>After a short moment, a two-window GUI will open up. GRASS uses some concepts and terminology that are pretty hard to get your head around becausr they are different to other GIS programs, particularly the idea of a “mapset”. You should be able to use the default, “PERMANENT” mapset for this tutorial, but I encourage you to look for some other GRASS tutorials that consider making your own mapsets. For now, you can just close or ignore the GUI windows as we will not be using them.</p>

<p>Let’s consider the GRASS 6.4 code (a shell script written in bash). Open <code class="highlighter-rouge">generate_los.sh</code> in a text editor. To do this with Gedit from the command line:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">gedit <span class="nb">source</span>/generate_los.sh</code></pre></figure>

<p>Browse through the file for a bit.</p>

<p>The very first line is a “shebang” that just tells the program loader what kind of interpreter to use. Here, we are using bash, as opposed to an alternative UNIX shell, like dash.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span></code></pre></figure>

<p>After that, we define a function called <code class="highlighter-rouge">usage</code>. Usage is called upon when checking inputs to the terminal when the code is executed. The function <code class="highlighter-rouge">usage</code> prints out a small bit of documentation for our code, telling a user that one of two possible arguments can be used: <code class="highlighter-rouge">-train</code> or <code class="highlighter-rouge">-road</code>. Choosing train will make sure the script uses some parameters that apply to traveling by train, and similarly for traveling by road.<label for="sn-id-disclaimer" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-id-disclaimer" class="margin-toggle" /><span class="sidenote">Disclaimer: I don’t actually know if this is proper practice for writing what is essentially help documentation. I can’t imagine it’s too far from this. </span></p>

<p>The <code class="highlighter-rouge">usage</code> function and argument parsing:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">usage<span class="o">()</span> <span class="o">{</span>
   cat <span class="sh">&lt;&lt; EOF
Usage: generate_los.sh [-train | -road]

-train    perform the viewshed analysis for the train journey
-road     perform the viewshed analysis for the road journey
EOF
</span>   <span class="nb">exit </span>1
<span class="o">}</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$# </span>-ne 1 <span class="o">]</span>; <span class="k">then</span>
   <span class="c"># Number of arguments</span>
   <span class="c"># If there is more or less than one, do usage()</span>
   usage;
<span class="k">fi

if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> !<span class="o">=</span> <span class="s2">"-train"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> !<span class="o">=</span> <span class="s2">"-road"</span> <span class="o">]</span>; <span class="k">then
  </span>usage;
<span class="k">fi</span></code></pre></figure>

<p><code class="highlighter-rouge">if [ $# -ne 1 ]; then</code> considers all of the arguments that a user enters alongside the command to execute the GRASS shell script. If the number of arguments is not equal to one (<code class="highlighter-rouge">-ne 1</code>), then the condition is reached: run the <code class="highlighter-rouge">usage</code> function.</p>

<p><code class="highlighter-rouge">usage</code> tells our naïve user that they have to run either (and only one of) these commands at the terminal to get things going:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">sh execute_los.sh -train
sh execute_los.sh -road</code></pre></figure>

<p>Failure to do so simply prints an instruction to the terminal, and causes the script to stop with exit code 1 (<code class="highlighter-rouge">exit 1</code>), a catch-all for general errors.</p>

<p>If the number of provided arguments is equal to one, we then check if this argument is in the realms of expectation (argument <code class="highlighter-rouge">"$1"</code> is <code class="highlighter-rouge">-train</code> or <code class="highlighter-rouge">-road</code>). If the first argument is not equal to <code class="highlighter-rouge">train</code> (<code class="highlighter-rouge">"$1" != "-train"</code>) or <code class="highlighter-rouge">-road</code>, then <code class="highlighter-rouge">usage</code> is triggered again. Otherwise we go on our merry way: setting up some variables according to <code class="highlighter-rouge">train</code> or <code class="highlighter-rouge">road</code>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="k">if</span> <span class="o">[</span> <span class="nv">$1</span> <span class="o">=</span> <span class="s2">"-road"</span> <span class="o">]</span>
<span class="k">then
    </span><span class="nv">LINE_SHP</span><span class="o">=</span><span class="s1">'../data/road/roads.shp'</span> <span class="c"># Roads shapefile</span>
    <span class="nv">PTS_FILE</span><span class="o">=</span><span class="s2">"../data/road/road_points_coords.csv"</span>
    <span class="c"># ^ An intermediate output of this script; coordinates of LINE_SHP</span>
    <span class="nv">ELEV</span><span class="o">=</span>1.2 <span class="c"># Metres above the ground that the observer stands</span>
    <span class="c"># ^ just a guess (note, try include the vehicle, too)</span>
    <span class="nv">OUTFILE</span><span class="o">=</span><span class="s2">"dist_los_car"</span> <span class="c"># Name of final output raster</span>
<span class="k">elif</span> <span class="o">[</span> <span class="nv">$1</span> <span class="o">=</span> <span class="s2">"-train"</span> <span class="o">]</span>
<span class="k">then</span>
    <span class="c"># We live in a post-shapefile world, baby!</span>
    <span class="nv">LINE_SHP</span><span class="o">=</span><span class="s1">'../data/train/nz-railway-centrelines-topo-150k.gpkg'</span> <span class="c"># Rail geopackage</span>
    <span class="nv">PTS_FILE</span><span class="o">=</span><span class="s2">"../data/train/rail_points_coords.csv"</span>
    <span class="c"># ^ An intermediate output of this script; coordinates of LINE_SHP</span>
    <span class="nv">ELEV</span><span class="o">=</span>2.5 <span class="c"># Metres above the ground that the observer stands</span>
    <span class="c"># ^ just a guess (note, try include the vehicle, too)</span>
    <span class="nv">OUTFILE</span><span class="o">=</span><span class="s2">"dist_los_rail"</span> <span class="c"># Name of final output raster</span>
<span class="k">else
    </span>usage; <span class="c"># shouldn't need this</span>
<span class="k">fi</span></code></pre></figure>

<p>We define a number of variables that have global scope for the remainder of the script:</p>

<p><span class="newthought"><code class="highlighter-rouge">LINE_SHP</code></span> : A line “shape”, or vector feature. GRASS is happy accepting a wide variety of vector formats, and we don’t even have to specify what they are. In my case, I downloaded both an Esri Shapefile (for the road following State Highway 1 between Auckland and Wellington) and a <a href="https://github.com/opengeospatial/geopackage">GeoPackage</a> (for the main trunk railroad of the North Island). Before running this script, I used QGIS to remove all features from my original dataset that I wasn’t interested in. I could have also performed this filtering in GRASS, which would have had the advantage of making it easier to change my region of interest another time.</p>

<p><span class="newthought"><code class="highlighter-rouge">PTS_FILE</code></span> : “points file”, a dataset that will be created in the course of the script’s execution, and represents points spaced along our original line features. These points represent all of the viewing opportunities we are going to calculate viewsheds for.</p>

<p><span class="newthought"><code class="highlighter-rouge">ELEV</code></span> : GRASS’ viewshed tools allow us to set observer heights. That is, if you’re trying to determine what you can see from your house, ideally you’d account for the fact that your eyes are not at ground level. Importantly, <strong>a train is higher up than a car</strong>, and defining the value of this variable <em>conditionally</em> allows us to be slightly more germane when coming up with the answer to our problem.</p>

<p><span class="newthought"><code class="highlighter-rouge">OUTFILE</code></span> : the name of the final output raster that we’ll collect up at the end and open to see the result. As we will see, the final output is actually just a GeoTiff (image with a spatial projection). It’s handy to have a different name depending on whether we are calculating train or road visibility, as we wouldn’t want one to overwrite the other.</p>

<p>Following the conditional variables, there are some variables that are considered constant regardless of our mode of transport:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">R_DEM</span><span class="o">=</span><span class="s1">'../data/hillshade/nidemreproj'</span> <span class="c"># Elevation DEM</span>
<span class="nv">R_RES</span><span class="o">=</span>25 <span class="c"># The resolution of the DEM (metres)</span>
<span class="nv">DIST_PTS</span><span class="o">=</span>25 <span class="c"># Ideally the resolution of the DEM</span>
<span class="nv">MAX_VIS_DIST</span><span class="o">=</span>30000 <span class="c"># Maximum distance visible</span></code></pre></figure>

<p><code class="highlighter-rouge">DIST_PTS</code> is a really important parameter. It will be used to determine how far our source viewing locations may be from one another. There is no point in this value being smaller than <code class="highlighter-rouge">R_RES</code>, because two different points that lie within the same cell of our terrain model will have the same viewable cells.</p>

<p><code class="highlighter-rouge">MAX_VIS_DIST</code> is also very important. It defines the maximum distance from one of our viewing spots that can be considered visible to an observer. It is stated in the same units as the projection system uses; which in my case is metres.</p>

<p>Together, these global variables determine the precision of our output, and therefore how much of a computational challenge this can be. Taking this to the extreme, you could look at a sub-metre terrain model, and consider a near-continuous movement of a passenger who can see for miles and miles… but you’d need a supercomputer or a very long time to get your output. And when your output is ready, it would still be subject to many of our original limitations (lack of trees is probably the biggest one). Your output would actually be subject to <a href="http://en.wikipedia.org/wiki/False_precision"><strong>false precision</strong></a>: a very important concept in GIScience.</p>

<p>While testing, I used a <code class="highlighter-rouge">MAX_VIS_DIST</code> of only 100 metres, and a <code class="highlighter-rouge">DIST_POINTS</code> of thousands of kilometres. This did not give me the actual output I was after, but tested the logic of the code and calculated very quickly even on the real datasets. The parameter values above are the ones that I used when making the real output, which took several days to calculate. This is still a very expensive calculation!</p>

<h3 id="preparation-for-grass-64">Preparation for GRASS 6.4</h3>

<p>Next up, we are preparing to actually use the command <code class="highlighter-rouge">r.los</code> (“raster”.”line of sight”). Here GRASS 7.0 has a strong advantage over GRASS 6.4. <a href="http://grass.osgeo.org/grass64/manuals/r.los.html">The documentation for <code class="highlighter-rouge">r.los</code></a> states the following:</p>

<blockquote>
  <p>The time to complete the calculation increases dramatically with the region size. Try to keep the columns and rows under 1000.</p>
</blockquote>

<p>The equivalent GRASS 7.0 command, not available in GRASS 6.4 is <code class="highlighter-rouge">r.viewshed</code>, and it does not suffer so.</p>

<p>In order to keep the number of rows and columns in our calculation under 1000, we actually need to adjust the variable <code class="highlighter-rouge">MAX_VIS_DIST</code> while considering <code class="highlighter-rouge">R_RES</code>, as the two are actually tightly linked. The following commands create a new intermediate variable, <code class="highlighter-rouge">POS_VIS_DIST</code> (possible visibility distance), which determines the maximum distance we can possibly define as “visible” without exceeding the limit of 1000 rows or 1000 columns in our visibility calculation. If <code class="highlighter-rouge">POS_VIS_DIST</code> ends up exceeding <code class="highlighter-rouge">MAX_VIS_DIST</code>, then we opt for <code class="highlighter-rouge">POS_VIS_DIST</code> by setting <code class="highlighter-rouge">MAX_VIS_DIST</code> equal to <code class="highlighter-rouge">POS_VIS_DIST</code>; otherwise we keep on with our original value of <code class="highlighter-rouge">MAX_VIS_DIST</code>.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># r.los takes a long time, and the manual says to keep</span>
<span class="c"># the number of rows and columns "under 1000". Here we</span>
<span class="c"># adjust MAX_VIS_DIST by considering the resolution of</span>
<span class="c"># the raster (R_RES), so that there is a maximum of</span>
<span class="c"># 1000 rows and columns</span>

<span class="c"># The maximum possible vis dist to use and still have</span>
<span class="c"># 1000 rows and cols</span>
<span class="nv">POS_VIS_DIST</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$R_RES</span><span class="s2"> * 1000 / 2"</span> | bc -l<span class="k">)</span>

<span class="k">if</span> <span class="o">[</span> 1 -eq <span class="sb">`</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$POS_VIS_DIST</span><span class="s2"> &lt; </span><span class="nv">$MAX_VIS_DIST</span><span class="s2">"</span> | bc<span class="sb">`</span> <span class="o">]</span>
<span class="k">then</span>
  <span class="c"># If the maximum distance r.los can sustain exceeds the</span>
  <span class="c"># user-selected value, override it</span>
  <span class="nb">echo</span> <span class="s2">"The MAX_VIS_DIST parameter has been changed </span><span class="se">\n</span><span class="s2">
  from </span><span class="nv">$MAX_VIS_DIST</span><span class="s2"> to </span><span class="nv">$POS_VIS_DIST</span><span class="s2"> for performance </span><span class="se">\n</span><span class="s2">
  reasons."</span>
  <span class="nv">MAX_VIS_DIST</span><span class="o">=</span><span class="nv">$POS_VIS_DIST</span>
<span class="k">fi</span></code></pre></figure>

<p>To understand this, we should consider what each line is actually doing.</p>

<p><code class="highlighter-rouge">POS_VIS_DIST=$(echo "$R_RES * 1000 / 2" | bc -l)</code> instantiates a variable that is equal to the resolution of the raster, multiplied by 500. This represents how many cells in any direction an observer can “look” without the number of rows or columns exceeding 1000. <code class="highlighter-rouge">bc</code> is a command to access “an arbitrary precision calculator language” (it calculates numbers). The pipe (<code class="highlighter-rouge">|</code>) is a way to connect the output of the left command to the input of the right command.</p>

<p>In the shell you could write:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">POS_VIS_DIST</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">"25 * 1000 /2"</span> | bc -l<span class="k">)</span>
<span class="nb">echo</span> <span class="nv">$POS_VIS_DIST</span></code></pre></figure>

<p>And it would spit out the value of your calculation: 12500</p>

<p>The next piece of logic is to compare this number to our <code class="highlighter-rouge">MAX_VIS_DIST</code> to see if it is larger:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="k">if</span> <span class="o">[</span> 1 -eq <span class="sb">`</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$POS_VIS_DIST</span><span class="s2"> &lt; </span><span class="nv">$MAX_VIS_DIST</span><span class="s2">"</span> | bc<span class="sb">`</span> <span class="o">]</span></code></pre></figure>

<p>Consider the following commands:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">v1</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">"10 &lt; 20"</span> | bc -l<span class="k">)</span>
<span class="nv">v2</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">"20 &lt; 10"</span> | bc -l<span class="k">)</span></code></pre></figure>

<p>Can you see that we’re doing inequality checks? The value of <code class="highlighter-rouge">v1</code> is 1, true (10 is less than 20); the value of <code class="highlighter-rouge">v2</code> is 0, false (20 is not less than 10). <code class="highlighter-rouge">if [ 1 -eq result ]</code> then asks “if 1 is equal to result”, or more fluidly, “if result is true”. If it is, then you can see above that we reset <code class="highlighter-rouge">MAX_VIS_DIST</code> as it violates our 1000 rows and columns constraint.</p>

<h3 id="distance-to-the-horizon">Distance to the horizon</h3>

<p>Now at this point it is a good idea to point out that I have actually picked arbitrary values for <code class="highlighter-rouge">MAX_VIS_DIST</code> in this example. There are more robust methods to determine the distance to the visible horizon that depend on the elevation of your position, and the curvature of the earth. The value can actually vary quite markedly. The GRASS documentation offers a nice approximation, but <code class="highlighter-rouge">r.los</code> itself does not take into account the curvature of the earth:</p>

<blockquote>
  <p>The curvature of the Earth is not taken into account for these calculations. However, for interest’s sake, a handy calculation for distance to the true horizon is approximated by &lt;div class="mathblock"&gt;<script type="math/tex; mode=display">d = \sqrt{(13 \times h)}</script>&lt;/div&gt;where <em>h</em> is the height of the observer in meters (above sea level) and <em>d</em> is the distance to the horizon in km. This may be useful for setting the max_dist value.</p>
</blockquote>

<p>You could implement this in GRASS with a bit of <code class="highlighter-rouge">bc</code> and considering the elevation value of each cell beneath each observer point, but I’ll leave that as an exercise for the reader (God I hate that). Consider this a reminder that any proposed solution to a geographic problem can almost always be improved.</p>

<p>A partial solution is to switch to GRASS 7.0: <a href="http://grass.osgeo.org/grass70/manuals/r.viewshed.html"><code class="highlighter-rouge">r.viewshed</code></a> allows a <code class="highlighter-rouge">-c</code> flag that considers the curvature of the earth better than you could—with reference to the current ellipsoid:</p>

<blockquote>
  <p>By default the elevations are not adjusted for the curvature of the earth. The user can turn this on with flag -c.</p>
</blockquote>

<p>However this <strong>still</strong> doesn’t resolve the problem of determining the actual distance to the horizon. In part, this is because that also depends on atmospheric conditions. For example, on an exceptionally clear day, when the atmospheric pressure is just right, you can actually make out Mt. Taranaki when standing on the Kāpiti Coast!</p>

<h3 id="further-preparation-for-the-line-of-sight-calculation">Further preparation for the line of sight calculation</h3>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># Load shapefile into GRASS</span>
v.in.ogr <span class="nv">dsn</span><span class="o">=</span><span class="nv">$LINE_SHP</span> <span class="nv">output</span><span class="o">=</span>line_feature --o --v

<span class="c"># Load elevation raster into GRASS and set it as the computational region</span>
r.in.gdal --o <span class="nv">input</span><span class="o">=</span><span class="nv">$R_DEM</span> <span class="nv">output</span><span class="o">=</span>dem --verbose

<span class="c"># Sample points along line</span>
v.to.points -ivt <span class="k">in</span><span class="o">=</span>line_feature <span class="nv">out</span><span class="o">=</span>line_feature_points <span class="nv">dmax</span><span class="o">=</span><span class="nv">$DIST_PTS</span> --o --q

<span class="c"># Put point coordinates in text file</span>
v.out.ascii -r <span class="k">in</span><span class="o">=</span>line_feature_points <span class="nv">fs</span><span class="o">=</span>, --quiet | awk -F <span class="s2">"</span><span class="se">\"</span><span class="s2">*,</span><span class="se">\"</span><span class="s2">*"</span> <span class="s1">'{print $1","$2}'</span> &gt; <span class="nv">$PTS_FILE</span>

<span class="nv">NPTS</span><span class="o">=</span><span class="sb">`</span>cat <span class="nv">$PTS_FILE</span> | wc -l<span class="sb">`</span></code></pre></figure>

<p>Try and see if you can work out what this section of code does. If you have GRASS running in your terminal, you can find out what any given GRASS command does with the following pattern: <code class="highlighter-rouge">r.command --help</code>, which is the same pattern for most commands at a UNIX terminal. You can also consult the online help.</p>

<p>To summarise the help documents for the GRASS commands used here:</p>

<ol>
  <li>
    <p><code class="highlighter-rouge">v.in.ogr</code>: Convert OGR vector layers to GRASS vector map.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">r.in.gdal</code>: Import GDAL supported raster file into a binary raster map layer.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">v.to.points</code>: Create points along input lines in new vector with 2 layers.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">v.out.ascii</code>: Converts a GRASS binary vector map to a GRASS ASCII vector map.</p>
  </li>
</ol>

<p>In conjunction with the <code class="highlighter-rouge">--help</code> option and my comments, try and work out what exactly these comments are doing. They represent a stage of data preparation for the next processing step. Remember that the syntax <code class="highlighter-rouge">$VARIABLE</code> is a way to access the value of the variable called <code class="highlighter-rouge">VARIABLE</code>, we defined several of these near the beginning of the script. If you have any questions, leave a comment.</p>

<h2 id="computing-viewsheds-iteratively">Computing viewsheds iteratively</h2>

<p>The general logic of the viewshed calculation is to take a series of points sampled along a line feature, find all places on the terrain model that a person standing on each point can see, and then mosaic each of these together into a final visibility surface. There are ways to make this smarter, such as using the fact that once a cell has been identified as visible from any point, to never bother querying whether it is visible again. I don’t explore these, although I might if I ever need to re-use this code.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">echo</span> -n <span class="s2">"</span><span class="se">\n</span><span class="s2">Computing viewsheds</span><span class="se">\n</span><span class="s2">"</span>

<span class="nv">COUNTER</span><span class="o">=</span>0
<span class="k">while </span><span class="nb">read</span> -r line
  <span class="k">do

  </span><span class="nv">PCT_FLOAT</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">"100*</span><span class="k">$((</span>COUNTER+1<span class="k">))</span><span class="s2">/</span><span class="nv">$NPTS</span><span class="s2">"</span> | bc -l<span class="k">)</span>
  <span class="nv">PCT</span><span class="o">=</span><span class="sb">`</span><span class="nb">printf</span> <span class="s2">"%0.1f</span><span class="se">\n</span><span class="s2">"</span> <span class="nv">$PCT_FLOAT</span><span class="sb">`</span>

  <span class="nb">echo</span> -ne <span class="s2">"Processing </span><span class="nv">$NPTS</span><span class="s2"> viewshed instances: </span><span class="se">\t</span><span class="s2"> </span><span class="nv">$PCT</span><span class="s2"> % (</span><span class="nv">$COUNTER</span><span class="s2">/</span><span class="nv">$NPTS</span><span class="s2">) </span><span class="se">\r</span><span class="s2">"</span>

  <span class="c"># Set the region to a smaller subset around the current observer point</span>
  <span class="c">#   to speed processing</span>
  <span class="nv">x</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$line</span> | cut -f1 -d,<span class="k">)</span>
  <span class="nv">y</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$line</span> | cut -f2 -d,<span class="k">)</span>
  <span class="nv">W</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$x</span><span class="s2">-</span><span class="nv">$MAX_VIS_DIST</span><span class="s2">"</span> | bc -l<span class="k">)</span>
  <span class="nv">E</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$x</span><span class="s2">+</span><span class="nv">$MAX_VIS_DIST</span><span class="s2">"</span> | bc -l<span class="k">)</span>
  <span class="nv">N</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$y</span><span class="s2">+</span><span class="nv">$MAX_VIS_DIST</span><span class="s2">"</span> | bc -l<span class="k">)</span>
  <span class="nv">S</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$y</span><span class="s2">-</span><span class="nv">$MAX_VIS_DIST</span><span class="s2">"</span> | bc -l<span class="k">)</span>
  g.region <span class="nv">n</span><span class="o">=</span><span class="nv">$N</span> <span class="nv">s</span><span class="o">=</span><span class="nv">$S</span> <span class="nv">e</span><span class="o">=</span><span class="nv">$E</span> <span class="nv">w</span><span class="o">=</span><span class="nv">$W</span>

  <span class="c"># Does not overwrite, so SIGINT (Ctrl+C) can be used to interrupt a</span>
  <span class="c">#  long-running process, to be resumed later</span>
  <span class="c">#  (keep parameters constant between runs)</span>
  r.los <span class="nv">input</span><span class="o">=</span>dem <span class="nv">output</span><span class="o">=</span>tmp_los_<span class="k">${</span><span class="nv">COUNTER</span><span class="k">}</span> <span class="nv">coordinate</span><span class="o">=</span><span class="nv">$line</span> <span class="nv">obs_elev</span><span class="o">=</span><span class="nv">$ELEV</span> <span class="nv">max_dist</span><span class="o">=</span><span class="nv">$MAX_VIS_DIST</span> --v
  <span class="nv">COUNTER</span><span class="o">=</span><span class="k">$((</span>COUNTER+1<span class="k">))</span>

<span class="k">done</span> &lt; <span class="nv">$PTS_FILE</span></code></pre></figure>

<p>We begin by creating a variable, <code class="highlighter-rouge">COUNTER</code>, to store our progress through an iteration. Then we start looping. That’s actually a bit hard to comprehend, so I’ll explain it closely:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="k">while </span><span class="nb">read</span> -r line
  <span class="k">do</span>
  <span class="c"># do something</span>
<span class="k">done</span> &lt; <span class="nv">$PTS_FILE</span></code></pre></figure>

<p>Notice that before this point, <code class="highlighter-rouge">line</code> didn’t exist. <code class="highlighter-rouge">line</code> is actually being defined on the last line of the loop syntax: <code class="highlighter-rouge">done &lt; $PTS_FILE</code> pipes the text file <code class="highlighter-rouge">$PTS_FILE</code>, representing a sequence of points along a line, into the for loop; each line of the file is then put into a variable called <code class="highlighter-rouge">$line</code> that we access during the execution of each loop.</p>

<p>The first thing that gets done in the body of the loop is to return some information to the terminal, reporting on the progress of the loop. See if you now understand enough about <code class="highlighter-rouge">bc</code> to see how <code class="highlighter-rouge">PCT_FLOAT</code> is the progress of the loop expressed as a percentage value of floating point precision. <code class="highlighter-rouge">PCT</code> stores the result rounded to one decimal place.</p>

<h3 id="grass-regions">GRASS regions</h3>

<p>Next up, we use a bit of black magic to speed up the processing. GRASS uses the concept of “regions” when running calculations. Every command will consider the current region, and nothing will be done outside of that region. So if you’re calculating a viewshed (a very expensive procedure), and you know the maximum distance that you consider viewable from any point, you can tell GRASS that its region can be as small as that area. Annotated code:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># Set the region to a smaller subset around the current observer point to speed processing</span>
<span class="c"># Note that this assumes the source line feature is projected in metres</span>
<span class="nv">x</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$line</span> | cut -f1 -d,<span class="k">)</span> <span class="c"># Get the x coordinate value from line, the current observer point</span>
<span class="nv">y</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$line</span> | cut -f2 -d,<span class="k">)</span> <span class="c"># The corresponding y value</span></code></pre></figure>

<p>Try <code class="highlighter-rouge">cut --help</code> coupled with the clue that <code class="highlighter-rouge">$line</code> is comma-delimited, if you don’t understand this.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">W</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$x</span><span class="s2">-</span><span class="nv">$MAX_VIS_DIST</span><span class="s2">"</span> | bc -l<span class="k">)</span> <span class="c"># x minus the maximum visible distance: the western reach of the region</span>
<span class="nv">E</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$x</span><span class="s2">+</span><span class="nv">$MAX_VIS_DIST</span><span class="s2">"</span> | bc -l<span class="k">)</span> <span class="c"># x + MAX_VIS_DIST: eastern reach</span>
<span class="nv">N</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$y</span><span class="s2">+</span><span class="nv">$MAX_VIS_DIST</span><span class="s2">"</span> | bc -l<span class="k">)</span> <span class="c"># y + MAX_VIS_DIST: northern reach</span>
<span class="nv">S</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$y</span><span class="s2">-</span><span class="nv">$MAX_VIS_DIST</span><span class="s2">"</span> | bc -l<span class="k">)</span> <span class="c"># y - MAX_VIS_DIST: southern reach</span></code></pre></figure>

<p>Finally, we use this command to actually set the region in each iteration: <code class="highlighter-rouge">g.region n=$N s=$S e=$E w=$W</code>. I found that resetting the region each loop was remarkably faster than leaving the region equal to the union of all inputs.</p>

<p>The final section of the loop performs the following:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">r.los <span class="nv">input</span><span class="o">=</span>dem <span class="nv">output</span><span class="o">=</span>tmp_los_<span class="k">${</span><span class="nv">COUNTER</span><span class="k">}</span> <span class="nv">coordinate</span><span class="o">=</span><span class="nv">$line</span> <span class="nv">obs_elev</span><span class="o">=</span><span class="nv">$ELEV</span> <span class="nv">max_dist</span><span class="o">=</span><span class="nv">$MAX_VIS_DIST</span> --v
<span class="nv">COUNTER</span><span class="o">=</span><span class="k">$((</span>COUNTER+1<span class="k">))</span></code></pre></figure>

<p><code class="highlighter-rouge">r.los</code> is the command that we’re really here for. It takes an input DEM, outputs a raster named <code class="highlighter-rouge">tmp_los_</code> plus whatever the counter is up to, a point value (our <code class="highlighter-rouge">$line</code> variable), and the observer elevation… and it goes away and tells us what that observer can see. Well, not really <em>what</em> they can see, more <em>where</em> they can see. The “what” can come later with some more Spatial Science™. For now, we close the loop and give it its input to set it in motion: <code class="highlighter-rouge">done &lt; $PTS_FILE</code>.</p>

<h3 id="one-viewshed-to-rule-them-all">One Viewshed To Rule Them All</h3>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># Set computational region to full extent</span>
g.region -pm <span class="nv">rast</span><span class="o">=</span>dem --verbose

<span class="c"># Combine results in a single map</span>
<span class="c">#   (aggregation method doesn't matter as we use</span>
<span class="c">#   this as a boolean mask)</span>
<span class="nb">echo</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Combining component viewsheds</span><span class="se">\n</span><span class="s2">"</span>
<span class="c"># Loops because otherwise can easily exceed default hard limit of number of</span>
<span class="c">#   rasters that can be open at once (1024)</span>
<span class="k">for </span>i <span class="k">in</span> <span class="sb">`</span>seq 0 99<span class="sb">`</span>;
<span class="k">do</span>
  <span class="c"># Combine a subset of all the viewsheds</span>
  <span class="c"># * is a wildcard for zero or more characters</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nv">$i</span> -le 9 <span class="o">]</span> <span class="c"># If i &lt;= 9</span>
  <span class="k">then</span> <span class="c"># append a 0 to the start of $i</span>
    <span class="nv">PATT</span><span class="o">=</span>tmp_los_<span class="k">*</span>0<span class="nv">$i</span>
    <span class="nv">OUT</span><span class="o">=</span>total_los_0<span class="nv">$i</span>
  <span class="k">else</span> <span class="c"># don't modify the pattern of $i</span>
    <span class="nv">PATT</span><span class="o">=</span>tmp_los_<span class="k">*</span><span class="nv">$i</span>
    <span class="nv">OUT</span><span class="o">=</span>total_los_<span class="nv">$i</span>
  <span class="k">fi
  </span>r.series <span class="k">in</span><span class="o">=</span><span class="sb">`</span>g.mlist --q <span class="nb">type</span><span class="o">=</span>rast <span class="nv">pattern</span><span class="o">=</span><span class="nv">$PATT</span> <span class="nv">sep</span><span class="o">=</span>,<span class="sb">`</span> <span class="nv">out</span><span class="o">=</span><span class="nv">$OUT</span> <span class="nv">method</span><span class="o">=</span>sum --o --q
<span class="k">done</span></code></pre></figure>

<p>Now that we have created each of the viewsheds for each of the points we sampled along the road or train line, we want to combine these individual raster layers into a single raster layer.</p>

<p>There is considerable scope for interesting complexity here. For instance, you could combine the results additively, thereby building a surface where each cell has a value from 0 (never seen) to a potentially very large number (seen from many of the points along the route). If you assume that the train travels at a constant speed, this surface would tell you how long you spend looking at any given 25x25 metre grid cell. You could then use this to determine what type of forest you spend more time looking at: native or exotic.</p>

<p>I’m going for an easy option: not worrying about how the layers are combined. I want a simple Boolean surface: can a cell be seen at any point in the trip, or can it never be seen? There’s no room for ambiguity, and the result is not as useful as the rest of the code allows it to be. But, I don’t have a “real” application for this to matter. If you want to fork the repository again on Github and explore this for yourself, go right ahead!</p>

<p>First, we use <code class="highlighter-rouge">g.region</code> to reset the region to the full extent of our input raster layer. Recall that without this command, the region would be stuck at whatever it was in the last iteration of the preceding loop!</p>

<p>Then (after some comments and printing information to stdout) we enter a loop that seems a little unnecessary. If we’re combining a bunch of raster layers together all at once, why do we need a loop? The answer is because GRASS 6.4 does not like it if you try and open more than 1024 rasters at any one time. As we would have made thousands of new rasters by this point, we cannot actually combine them all at once; rather we have to do it gingerly, in stages.</p>

<p>Therefore the pseudo-code is to:</p>

<ol>
  <li>
    <p>Start a loop from 0 to 99</p>
  </li>
  <li>
    <p>Get the value of the iterator in the style of 00, 01, 02, …, 98, 99 (i.e. a leading zero for numbers less than 10).</p>
  </li>
  <li>
    <p>Create a pattern variable (<code class="highlighter-rouge">PATT</code>) to store the pattern that our input point-specific viewshed rasters follow if their filename ends with 01, or 02, or whatever the iterator is at. (This will allow us to process roughly 1% of the input rasters in each step.)</p>
  </li>
  <li>
    <p>Perform the actual combination for a subset of the layers matching <code class="highlighter-rouge">PATT</code>.</p>
  </li>
</ol>

<p><code class="highlighter-rouge">r.series</code> is the key command of the above codeblock. It takes as its <code class="highlighter-rouge">in</code> parameter a list of layers that is constructed by a second command, <code class="highlighter-rouge">g.mlist</code>.</p>

<p><code class="highlighter-rouge">.g.mlist</code> is a <strong>very</strong> handy GRASS command. Take a look at its description in its help:</p>

<blockquote>
  <p>Lists available GRASS data base files of the user-specified data type optionally using the search pattern.</p>
</blockquote>

<p>So when we want to combine only a fraction of our intermediate viewshed rasters at one time, we tell <code class="highlighter-rouge">g.mlist</code> to go away and find all layers that match a particular pattern (e.g. all rasters called <code class="highlighter-rouge">"name_\*00"</code>, where * is a wildcard—that is, all of our intermediate layers ending in “00”). <code class="highlighter-rouge">r.series</code> then takes this list of layers and combines them with the <code class="highlighter-rouge">method</code> we have specified. (I used <code class="highlighter-rouge">sum</code>, although as I said I actually ignore this.)</p>

<p>What we’re then left with is a series of 99 raster layers, each representing a small part of what will become our finished product.<label for="sn-id-realisation" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-id-realisation" class="margin-toggle" /><span class="sidenote">I realise now that it would be smarter to combine the intermediate layer with the pattern-match layers as part of the above loop… but at the price of one additional <code class="highlighter-rouge">r.series</code> it ain’t the end of the world. </span></p>

<p>So, combine these up into our finished product with another pattern matching exercise:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">r.series <span class="k">in</span><span class="o">=</span><span class="sb">`</span>g.mlist --q <span class="nb">type</span><span class="o">=</span>rast <span class="nv">pattern</span><span class="o">=</span>total_los_<span class="k">*</span> <span class="nv">sep</span><span class="o">=</span>,<span class="sb">`</span> <span class="nv">out</span><span class="o">=</span>total_los <span class="nv">method</span><span class="o">=</span>sum --o --q</code></pre></figure>

<p>You could display the result now if you wanted the map to represent the number of times each cell has been determined as being “viewable”. I actually like the idea of a binary (viewable/not viewable) surface, where shading can be used to indicate distance from the line feature. So that’s what I’ll do. However it may be a little misleading, as distance from the line feature used in the exercise is not technically synonymous with the minimum distance from which it can be seen!</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># Create distance to line_feature map</span>
<span class="nb">echo</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Determining distance from features</span><span class="se">\n</span><span class="s2">"</span>
v.to.rast <span class="k">in</span><span class="o">=</span>line_feature <span class="nv">out</span><span class="o">=</span>line_feature <span class="nv">use</span><span class="o">=</span>val <span class="nv">val</span><span class="o">=</span>1 --o --q
r.grow.distance -m <span class="nv">input</span><span class="o">=</span>line_feature <span class="nv">distance</span><span class="o">=</span>dist_from_line_feature --o --q</code></pre></figure>

<p>This takes our line feature input and turns it into a raster; it then “grows” (raster buffers) this line… how far? To the same size as the entire GRASS region. There is no need to tell GRASS that; and it stores the output surface as a dataset specified by the rather misleading title of <code class="highlighter-rouge">distance</code>.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># Use distance to line_feature instead of sum of times seen in the result map</span>
<span class="nb">echo</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Substituting number of times seen for distance to cell from line</span><span class="se">\n</span><span class="s2">"</span>
r.mapcalc <span class="s2">"</span><span class="nv">$OUTFILE</span><span class="s2"> = if(total_los, dist_from_line_feature, null())"</span> --o --v</code></pre></figure>

<p>Here we use a bit of raster calculation (otherwise known as image manipulation) to make a new layer. To put the if statement into human terms: “if there is a  non-null value of <code class="highlighter-rouge">total_los</code> (i.e. a cell has been identified as visible), substitute its value with the value of the equivalent cell from the layer <code class="highlighter-rouge">dist_from_line_feature</code> (a raster surface where each cell knows its minimum distance from the line feature), otherwise make its value null.</p>

<p>The rest should be self-explanatory:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># Write output (as geotiff)</span>
r.out.gdal <span class="nv">input</span><span class="o">=</span><span class="nv">$OUTFILE</span> <span class="nv">output</span><span class="o">=</span>../data/output/<span class="nv">$OUTFILE</span>.tif <span class="nv">format</span><span class="o">=</span>GTiff --o --v

<span class="c"># Clean up, removing the component visibility rasters, only after outputs have been written</span>
<span class="nb">echo</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Deleting temporary files</span><span class="se">\n</span><span class="s2">"</span>
g.mremove -f <span class="s2">"tmp_los_*"</span> --q
g.mremove -f <span class="s2">"total_los_*"</span> --q

<span class="nb">echo</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">generate_los.sh complete</span><span class="se">\n</span><span class="s2">"</span></code></pre></figure>

<p>The final output is simply a GeoTiff. Try opening it in QGIS if you have been playing along at home. If you’re just reading, then in the <a href="http://www.nearimprov.com/train-landscapes">interactive map</a>, the output GeoTiff is the special coloured layer you see on top of the basemap.</p>

<p>So how do we get to this next stage?</p>

<h1 id="making-mapnik-tiles-with-qtiles">Making Mapnik tiles with QTiles</h1>

<p>There are a variety of ways to make map tiles.<label for="sn-id-tiles" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-id-tiles" class="margin-toggle" /><span class="sidenote">Don’t know what tiles are? That’s OK, everyone had to find out at some point. I really liked <a href="http://lyzidiamond.com/leaflet/#0">this introduction</a> by <a href="https://twitter.com/lyzidiamond">Lyzi Diamond</a>. </span> The simplest method for constructing map tiles, in my opinion, is to use a QGIS plugin called <a href="https://github.com/nextgis/QTiles">QTiles</a>. You can control all your styling and extents with QGIS layers, and then just tell the plugin to go away and make your map tiles.</p>

<p>To find out how to install a QGIS plugin, look <a href="http://www.qgistutorials.com/en/docs/using_plugins.html">here</a>.</p>

<p>The process for our purposes is rather simple.</p>

<ol>
  <li>
    <p>The GRASS script spits out a GeoTiff.</p>
  </li>
  <li>
    <p>You add that to a QGIS project via the add raster layer button.</p>
  </li>
  <li>
    <p>The GRASS script also had access to a vector line feature (as well as creating a CSV point dataset from that). You can add one or both of these via the add vector layer button.</p>
  </li>
  <li>
    <p>To add context, add a pre-existing baselayer, or make your own. For example, you could create a colour relief map (hypsometric tint). <a href="https://www.mapbox.com/tilemill/docs/guides/terrain-data/">Mapbox has a good tutorial using more command line GIS</a>, this time GDAL. I just took the easy route (again), and went for a Web Mapping Service (<a href="https://data.linz.govt.nz/p/web-services/">WMS</a>) from the good folk at Landcare Research. Look for the add data button in the sidebar with the tooltip “Add WMS/WMST Layer”. When it opens, create a new connection using the URL to the Landcare Research WMS: <code class="highlighter-rouge">http://maps.scinfo.org.nz/basemaps/wms?</code>. There are a variety of layers you can add (see image); the one I used is called the “Landcover Terrain Map”.</p>
  </li>
  <li>
    <p>Once you’ve added this basemap, styled and ordered your layers and are happy with the appearance of your map, install QTiles and fire it up via the menu Plugins &gt; QTiles &gt; QTiles. See the second image below for example parameters. Just be cautious before going ahead with your settings: you are generating exponentially more tiles (i.e. PNG images) for each additional level of zoom (1 is the most zoomed out, 18 is the most zoomed in). I only generated tiles between zoom levels 7 and 13, because I knew I was going to restrict the user to these zoom levels in the end. Allow the tool to run, and you’re ready to make a web map.</p>
  </li>
</ol>

<p><br /></p>
<figure class="fullwidth"><img src="/./assets/LR-example.png" /><figcaption>Screenshot from QGIS 2.8, of the Landcare Research WMS.</figcaption></figure>

<p><br /></p>
<figure class="fullwidth"><img src="/./assets/qtiles.png" /><figcaption>Screenshot from QGIS 2.8, QTiles plugin.</figcaption></figure>

<h1 id="making-a-web-ready-map-with-leaflet">Making a web-ready map with Leaflet</h1>

<p>There are lots of good tutorials on making webmaps, and I encourage you to explore them. I don’t consider myself very good at making them (yet). This is a very simple example, using two tile datasets and allowing the user to switch between them.</p>

<p>First, let’s look at the HTML: the webpage that will contain our map. (The map itself is made in a Javascript script.) The HTML is divided into the <code class="highlighter-rouge">head</code> and the <code class="highlighter-rouge">body</code>.</p>

<p>The head:</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"utf-8"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"X-UA-Compatible"</span> <span class="na">content=</span><span class="s">"IE=edge"</span><span class="nt">&gt;</span>

  <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"viewport"</span> <span class="na">content=</span><span class="s">"width=device-width, initial-scale=1.0"</span><span class="nt">&gt;</span>

  <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">href=</span><span class="s">"http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.css"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">href=</span><span class="s">"./source/style.css"</span> <span class="nt">/&gt;</span>

  <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"Content-type"</span> <span class="na">content=</span><span class="s">"text/html; charset=utf-8"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/head&gt;</span></code></pre></figure>

<p>This is all pretty standard, if you’ve ever hit “View Page Source” on a webpage. Can you see where we tell the page to read the Leaflet CSS (<code class="highlighter-rouge">leaflet.css</code>)? And a custom bit of CSS (<code class="highlighter-rouge">style.css</code>)?</p>

<p>Now for the body:</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;body&gt;</span>
    <span class="c">&lt;!-- header div --&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"title-text"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;h2&gt;</span>
        Travelling overland between Auckland and Wellington: what can you see?
      <span class="nt">&lt;/h2&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
    <span class="c">&lt;!-- map div --&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"map"</span><span class="nt">&gt;&lt;/div&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"./source/make_map.js"</span> <span class="na">type=</span><span class="s">"text/javascript"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span></code></pre></figure>

<p>We have two <code class="highlighter-rouge">div</code> elements in the body, and two scripts. The first <code class="highlighter-rouge">div</code> contains the header text you see at the top of the map. The second <code class="highlighter-rouge">div</code>, with the ID of <code class="highlighter-rouge">"map"</code>, contains our map, although there is very little indication yet that it actually does anything. The clue lies in the two pieces of Javascript that get loaded next. The first is the standard Leaflet Javascript that brings along the functionality of every Leaflet slippy map you’ve ever seen. The second is a custom bit of code where we specify our own special map. This bit of code is in the Github repo, and is called <code class="highlighter-rouge">make_map.js</code>. Let’s take a look at that next.</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span>  <span class="nx">carViewshed</span> <span class="o">=</span> <span class="s1">'https://s3-ap-southeast-2.amazonaws.com/train-landscapes/car/{z}/{x}/{y}.png'</span><span class="p">,</span>
    <span class="nx">trainViewshed</span> <span class="o">=</span> <span class="s1">'https://s3-ap-southeast-2.amazonaws.com/train-landscapes/rail/Mapnik/{z}/{x}/{y}.png'</span><span class="p">,</span>
    <span class="nx">southWest</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">41.722</span><span class="p">,</span><span class="mf">171.748</span><span class="p">],</span>
    <span class="nx">northEast</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">36.441</span><span class="p">,</span><span class="mf">179.124</span><span class="p">],</span>
    <span class="nx">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="nx">southWest</span><span class="p">,</span> <span class="nx">northEast</span><span class="p">],</span>
    <span class="nx">attribution</span> <span class="o">=</span> <span class="s1">'Richard Law | \
    Pierre Roudier | \
    Basemap © &lt;a href="http://maps.scinfo.org.nz/"&gt;Landcare Research&lt;/a&gt; 2014. Contains data sourced from LINZ. Crown Copyright Reserved. &lt;a href="http://creativecommons.org/licenses/by/3.0/nz/"&gt;CC BY 3.0 NZ&lt;/a&gt; | \
    &lt;a href="https://koordinates.com/layer/40-nz-road-centrelines-topo-150k/"&gt;LINZ&lt;/a&gt; &lt;a href="http://creativecommons.org/licenses/by/3.0/nz/"&gt;CC BY 3.0 NZ&lt;/a&gt; | \
    &lt;a href="http://grass.osgeo.org/"&gt;GRASS GIS&lt;/a&gt;'</span><span class="p">,</span>
    <span class="nx">global_min_zoom</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
    <span class="nx">global_max_zoom</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">L</span><span class="p">.</span><span class="nx">Map</span><span class="p">(</span><span class="s1">'map'</span><span class="p">);</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">setView</span><span class="p">([</span><span class="o">-</span><span class="mf">38.6875</span><span class="p">,</span> <span class="mf">176.0694</span><span class="p">],</span> <span class="mi">7</span><span class="p">);</span> <span class="c1">//centre and zoom of map, initially</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">setMaxBounds</span><span class="p">(</span><span class="nx">bounds</span><span class="p">);</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">minZoom</span> <span class="o">=</span> <span class="nx">global_min_zoom</span><span class="p">;</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">maxZoom</span> <span class="o">=</span> <span class="nx">global_max_zoom</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">car</span> <span class="o">=</span> <span class="nx">L</span><span class="p">.</span><span class="nx">tileLayer</span><span class="p">(</span><span class="nx">carViewshed</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">attribution</span><span class="p">:</span> <span class="nx">attribution</span><span class="p">,</span>
  <span class="na">bounds</span><span class="p">:</span> <span class="nx">bounds</span><span class="p">,</span>
  <span class="na">minZoom</span><span class="p">:</span> <span class="nx">global_min_zoom</span><span class="p">,</span>
  <span class="na">maxZoom</span><span class="p">:</span> <span class="nx">global_max_zoom</span><span class="p">,</span>
  <span class="na">tms</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">isBaseLayer</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="c1">//opacity: 0.7,</span>
  <span class="c1">//transparent: true</span>
<span class="p">}).</span><span class="nx">addTo</span><span class="p">(</span><span class="nx">map</span><span class="p">);</span> <span class="c1">//default layer, so add to map</span>

<span class="kd">var</span> <span class="nx">train</span> <span class="o">=</span> <span class="nx">L</span><span class="p">.</span><span class="nx">tileLayer</span><span class="p">(</span><span class="nx">trainViewshed</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">attribution</span><span class="p">:</span> <span class="nx">attribution</span><span class="p">,</span>
  <span class="na">bounds</span><span class="p">:</span> <span class="nx">bounds</span><span class="p">,</span>
  <span class="na">minZoom</span><span class="p">:</span> <span class="nx">global_min_zoom</span><span class="p">,</span>
  <span class="na">maxZoom</span><span class="p">:</span> <span class="nx">global_max_zoom</span><span class="p">,</span>
  <span class="na">tms</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">isBaseLayer</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="c1">//opacity: 0.7,</span>
  <span class="c1">//transparent: true</span>
<span class="p">});</span> <span class="c1">//non-default layer, so don't add to map</span>

<span class="kd">var</span> <span class="nx">viewshedBasemaps</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"Car/bus view"</span><span class="p">:</span> <span class="nx">car</span><span class="p">,</span>
    <span class="s2">"Overlander view"</span><span class="p">:</span> <span class="nx">train</span>
<span class="p">};</span>

<span class="nx">L</span><span class="p">.</span><span class="nx">control</span><span class="p">.</span><span class="nx">layers</span><span class="p">(</span><span class="nx">viewshedBasemaps</span><span class="p">).</span><span class="nx">addTo</span><span class="p">(</span><span class="nx">map</span><span class="p">);</span> <span class="c1">// Add the layer control to the map</span></code></pre></figure>

<p>The first unbroken section of code above creates a bunch of variables. While the <code class="highlighter-rouge">var</code> keyword is only used once, it could be used on each line if the commas at the end were omitted. <code class="highlighter-rouge">carViewshed</code> and <code class="highlighter-rouge">trainViewshed</code> are the relative paths to the hosted folders that contain the tiles we made earlier with QTiles. (I’ll explain the Amazon business soon.) <code class="highlighter-rouge">southWest</code> and <code class="highlighter-rouge">northEast</code> are global parameters that I use to constrain the user’s ability to move: I only want them to be able to scroll around the North Island… mostly because that’s the only place I’ve actually created any map. The variables <code class="highlighter-rouge">attribution</code>, if you’re paying attention, is the bit of text you see at the bottom of the map. Leaflet is good about using that, and so should you be.</p>

<p>Notice that <code class="highlighter-rouge">global_max_zoom</code> and <code class="highlighter-rouge">global_min_zoom</code> correspond to the numbers I used in the tile generation step. I didn’t make tiles beyond the range 7-13, so I don’t let the user zoom beyond that range (otherwise they’d see nothing).</p>

<p>I then make a very important variable, <code class="highlighter-rouge">map</code>, and set a few of its options:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">L</span><span class="p">.</span><span class="nx">Map</span><span class="p">(</span><span class="s1">'map'</span><span class="p">);</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">setView</span><span class="p">([</span><span class="o">-</span><span class="mf">38.6875</span><span class="p">,</span> <span class="mf">176.0694</span><span class="p">],</span> <span class="mi">7</span><span class="p">);</span> <span class="c1">//centre and zoom of map, initially</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">setMaxBounds</span><span class="p">(</span><span class="nx">bounds</span><span class="p">);</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">minZoom</span> <span class="o">=</span> <span class="nx">global_min_zoom</span><span class="p">;</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">maxZoom</span> <span class="o">=</span> <span class="nx">global_max_zoom</span><span class="p">;</span></code></pre></figure>

<p>Later, we will call on this <code class="highlighter-rouge">map</code> to actually display (you guessed it) a map.</p>

<p>But first, I need to tell it what it’s allowed to display.</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">car</span> <span class="o">=</span> <span class="nx">L</span><span class="p">.</span><span class="nx">tileLayer</span><span class="p">(</span><span class="nx">carViewshed</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">attribution</span><span class="p">:</span> <span class="nx">attribution</span><span class="p">,</span>
  <span class="na">bounds</span><span class="p">:</span> <span class="nx">bounds</span><span class="p">,</span>
  <span class="na">minZoom</span><span class="p">:</span> <span class="nx">global_min_zoom</span><span class="p">,</span>
  <span class="na">maxZoom</span><span class="p">:</span> <span class="nx">global_max_zoom</span><span class="p">,</span>
  <span class="na">tms</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">isBaseLayer</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="c1">//opacity: 0.7,</span>
  <span class="c1">//transparent: true</span>
<span class="p">}).</span><span class="nx">addTo</span><span class="p">(</span><span class="nx">map</span><span class="p">);</span> <span class="c1">//default layer, so add to map</span>

<span class="kd">var</span> <span class="nx">train</span> <span class="o">=</span> <span class="nx">L</span><span class="p">.</span><span class="nx">tileLayer</span><span class="p">(</span><span class="nx">trainViewshed</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">attribution</span><span class="p">:</span> <span class="nx">attribution</span><span class="p">,</span>
  <span class="na">bounds</span><span class="p">:</span> <span class="nx">bounds</span><span class="p">,</span>
  <span class="na">minZoom</span><span class="p">:</span> <span class="nx">global_min_zoom</span><span class="p">,</span>
  <span class="na">maxZoom</span><span class="p">:</span> <span class="nx">global_max_zoom</span><span class="p">,</span>
  <span class="na">tms</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">isBaseLayer</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="c1">//opacity: 0.7,</span>
  <span class="c1">//transparent: true</span>
<span class="p">});</span> <span class="c1">//non-default layer, so don't add to map</span></code></pre></figure>

<p>I made two tile datasets, for the view from the car and from the train. The syntax for accessing them is naturally quite similar. There are more settings I didn’t play with, and I even commented out two that didn’t work very well after some experimentation.</p>

<p>Without this next block of code, the map would function, but you would never be able to get to the <code class="highlighter-rouge">train</code> tiles. So we add a controller to allow a user to switch between our two sets of map tiles:</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">viewshedBasemaps</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"Car/bus view"</span><span class="p">:</span> <span class="nx">car</span><span class="p">,</span>
    <span class="s2">"Overlander view"</span><span class="p">:</span> <span class="nx">train</span>
<span class="p">};</span>

<span class="nx">L</span><span class="p">.</span><span class="nx">control</span><span class="p">.</span><span class="nx">layers</span><span class="p">(</span><span class="nx">viewshedBasemaps</span><span class="p">).</span><span class="nx">addTo</span><span class="p">(</span><span class="nx">map</span><span class="p">);</span> <span class="c1">// Add the layer control to the map</span></code></pre></figure>

<p><code class="highlighter-rouge">L</code> refers to Leaflet, and I nutted out this bit of code by reading their excellent documentation. Note that <code class="highlighter-rouge">car</code> and <code class="highlighter-rouge">train</code> here are the <code class="highlighter-rouge">L.tileLayer</code> variables we just defined. We tell Leaflet that we have two tile layers that we want to add to its set of <code class="highlighter-rouge">control.layers</code>.</p>

<p>The final bit of work is to add some CSS. Stepping through the below code, we have the style for:</p>

<ol>
  <li>
    <p>The webpage as a whole.</p>
  </li>
  <li>
    <p>The title text you see at the top of the webpage.</p>
  </li>
  <li>
    <p>The “map” <code class="highlighter-rouge">div</code>.</p>
  </li>
  <li>
    <p>The container of the leaflet map, which I have made transparent so that it is white like the rest of the page background.</p>
  </li>
  <li>
    <p>A style for the layer control so it pops more than the default. I wanted to emphasise the layer selector, as it is really the entire point of making contrasting viewsheds. This bit of CSS is a little complex; the best way to work it out is to fiddle with it.</p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-css" data-lang="css"><span class="nt">html</span><span class="o">,</span> <span class="nt">body</span> <span class="p">{</span>
    <span class="nl">height</span><span class="p">:</span> <span class="m">100%</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">#title-text</span><span class="p">{</span>
  <span class="nl">height</span><span class="p">:</span> <span class="m">8%</span><span class="p">;</span>
  <span class="nl">width</span><span class="p">:</span> <span class="m">100%</span><span class="p">;</span>
  <span class="nl">font-family</span><span class="p">:</span> <span class="n">Helvetica</span><span class="p">;</span>
  <span class="nl">text-align</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
<span class="p">}</span>

<span class="nf">#map</span><span class="p">{</span>
   <span class="nl">height</span><span class="p">:</span> <span class="m">89%</span><span class="p">;</span>
   <span class="nl">width</span><span class="p">:</span> <span class="m">100%</span><span class="p">;</span>
   <span class="p">}</span>

<span class="c">/* background of leaflet container: transparent \*/</span>
<span class="nc">.leaflet-container</span> <span class="p">{</span>
    <span class="nl">background-color</span><span class="p">:</span><span class="n">rgba</span><span class="p">(</span><span class="m">255</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">0.0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c">/* custom style for the layer control to make it a bit more obvious \*/</span>
<span class="nc">.leaflet-control-layers-toggle</span><span class="nd">:after</span><span class="p">{</span>
    <span class="nl">content</span><span class="p">:</span><span class="s1">"Toggle transport mode"</span><span class="p">;</span>
    <span class="nl">color</span><span class="p">:</span><span class="m">#000</span> <span class="p">;</span>
<span class="p">}</span>
<span class="nc">.leaflet-control-layers-toggle</span><span class="p">{</span>
    <span class="nl">width</span><span class="p">:</span><span class="nb">auto</span><span class="p">;</span>
    <span class="nl">background-position</span><span class="p">:</span><span class="m">10px</span> <span class="m">50%</span> <span class="p">;</span>
    <span class="nl">padding</span><span class="p">:</span><span class="m">6px</span><span class="p">;</span>
    <span class="nl">padding-left</span><span class="p">:</span><span class="m">40px</span><span class="p">;</span>
    <span class="nl">padding-right</span><span class="p">:</span><span class="m">10px</span><span class="p">;</span>
    <span class="nl">text-decoration</span><span class="p">:</span><span class="nb">none</span><span class="p">;</span>
    <span class="nl">line-height</span><span class="p">:</span><span class="m">36px</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h1 id="getting-the-map-online">Getting the map online</h1>

<p>So, you have used a complex geographic routine to make a cool viewshed for the North Island of New Zealand. You have made a working web map and added some custom flair. How do you show it off? There are lots of ways to host webpages, but since we’re using Github, Github is actually a very good option for projects like these.</p>

<p>In any Github project, if you make a branch called <code class="highlighter-rouge">gh-pages</code>, some magic happens. <a href="https://pages.github.com/">Github is the authority on the matter</a>. Once you have your username.github.io repository ready, any <em>other</em> repository you make can have a hosted website simply by making a <code class="highlighter-rouge">gh-pages</code> branch.</p>

<p>If this branch has an HTML file called <code class="highlighter-rouge">index.html</code>, you can then find your special Github-hosted webpage via the URL: <code class="highlighter-rouge">https://{username}.github.io/{repository}</code>. If this page happens to contain a map… then you have a map available on the Internet for the world to see, for free. You just have to be comfortable with the code (and often data) behind it being open to anyone.</p>

<p>You can go one step further and also get a custom domain name, if you want to be able to link to something like https://www.nearimprov.com/train-landscapes.</p>

<h2 id="amazon-aws">Amazon AWS</h2>

<p>There’s just one little problem left. The two sets of tiles, even though they have a constrained range of zoom levels and geographic extent, come to about three gigabytes of images. Github doesn’t like that (I tried). So you need an alternative. Some kind of system where you can put lots of images in a directory structure on the Internet, and access them with a persistent URL. Amazon Web Services (AWS) is the cloud solution for you!</p>

<p>If you sign up for an AWS account and navigate to your console, you should be able to see where you can create a “bucket”. Once you’ve made your bucket, you can then create folders just like any other directory. Then, inside each folder, you can store your tiles.</p>

<p><br /></p>
<figure class="fullwidth"><img src="/./assets/aws1.png" /><figcaption></figcaption></figure>

<p><br /></p>
<figure class="fullwidth"><img src="/./assets/aws2.png" /><figcaption></figcaption></figure>

<p>There are two catches:</p>

<ol>
  <li>
    <p>AWS is not free. Beyond a certain number of downloads you will be charged; I intend to monitor mine and remove the files before this happens.</p>
  </li>
  <li>
    <p>You need to programmatically upload your tiles, so you need to go back to that shell you love so well.</p>
  </li>
</ol>

<p>You need to install and configure <code class="highlighter-rouge">s3cmd</code>. On Ubuntu it’s in the official repositories, so it’s as easy as the command <code class="highlighter-rouge">sudo apt-get install s3cmd</code>. I have no idea how easy or difficult this is on other operating systems (I told you to use Linux!)</p>

<p>If you’ve sorted your account through your web browser, you need to request your access keys from your managment console. You’ll get given two of them, sent to you in a download that you keep to yourself. When you have these in front of you run <code class="highlighter-rouge">s3cmd --configure</code> at the command line and provide the keys when requested. I just used the default answers to all the other questions.</p>

<p>Now if you have set up your bucket and two folders “car” and “rail”, you can sync your local tiles generated with QTiles to Amazon CloudFront. This is also a relatively easy command, just be aware how much bandwidth you’re using.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">s3cmd sync /path/to/car/tiles/ s3://bucket-name/car</code></pre></figure>

<p>Repeat the above with your other tile dataset. Refer back to the Javascript to see how I the referred to the URLs where you can see these images. You can see an example tile <a href="https://s3-ap-southeast-2.amazonaws.com/train-landscapes/car/10/1007/381.png">here</a>, while it lasts.</p>

<p><br /></p>
<figure class="fullwidth"><img src="/./assets/aws3.png" /><figcaption></figcaption></figure>

<p><br /></p>
<figure class="fullwidth"><img src="/./assets/aws4.png" /><figcaption></figcaption></figure>

<h3 id="local-tiles">Local tiles</h3>

<p>Obviously in order to put tiles on Amazon’s servers, you also need to have generated tiles locally. You can use these with Leaflet to preview your map offline. Simple substitute the URLs I used for carViewshed and trainViewshed with local paths, e.g.</p>

<figure class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">carViewshed</span> <span class="o">=</span> <span class="s1">'/data/tiles/rail/Mapnik/{z}/{x}/{y}.png'</span></code></pre></figure>

<p>Then you can use Python from your command line to serve up a webpage (Python 2.x):</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">python -m SimpleHTTPServer</code></pre></figure>

<p>Check out <a href="http://localhost:8000/">http://localhost:8000/</a> once this server is running. (Press ctrl-c to get back in control of your command line.)</p>

<p><span class="newthought">I’ve been frustrated many times in the past</span>  by the need to patch together a series of tutorials from different authors to actually get my own project off the ground, from data to a finished product. I hope this has been helpful for you to realise something from your own imagination.</p>

<p>If there’s any element that you feel needs better explanation, please leave a comment and I’ll help you out.</p>

<p>Similarly, if there’s anything that you feel is a glaring mistake in my code, point it out, I’d love to improve. I’m sure I’m fallible: Pierre’s bash script was the first piece of bash that I’d ever read; my changes were my first experience with shell scripts. I’ve since found them very useful.</p>

<p>Have fun!</p>



<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'nearimprov';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

 <!--
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'nearimprov';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

-->

    </article>
    <span class="print-footer">The things you see on a journey<br><small>A tutorial on GRASS, bash and Leaflet</small> - June 1, 2015 - Richard Law</span>
    <footer>
  <hr class="slender">
  <ul class="footer-links">
    
      <li>
        <a href="//www.twitter.com/alphabeta_soup"><span class="icon-twitter"></span></a>
      </li>
    
      <li>
        <a href="//plus.google.com/+RichardLawNZ"><span class="icon-googleplus"></span></a>
      </li>
    
      <li>
        <a href="//github.com/alpha-beta-soup"><span class="icon-github"></span></a>
      </li>
    
      <li>
        <a href="/blog/feed.xml"><span class="icon-feed"></span></a>
      </li>
    
      <li>
        <a href="mailto:richard.m.law@gmail.com"><span class="icon-mail"></span></a>
      </li>
    
  </ul>
<div class="credits">
<!-- <span>&copy; 2016 &nbsp;&nbsp;RICHARD LAW</span></br> <br> -->
<span>This site is created with the <a href="//github.com/clayh53/tufte-jekyll">Tufte theme </a> for <a href="//jekyllrb.com">Jekyll</a>.</span>
</div>
</footer>

  </body>
</html>
